*** Can We Run Without Main Thread?

‚ùå No.

Because:

JVM needs an entry point.

Execution must start from main() method.

JVM creates main thread automatically.

But you can:

Start custom threads

Let main thread finish early

Keep program alive using other threads

Example : 

class MyThread extends Thread {
    public void run() {
        while(true) {
            System.out.println("Running...");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        new MyThread().start();
    }
}

Here:

Main thread finishes quickly

Custom thread keeps running

üî• Interview Answer

No, we cannot create a Java program without a main thread because JVM always creates one. However, 
we can create custom threads using Thread class or Runnable interface.

/**
 * Q12) Can we override start() method?
 *  	yes, no CE, no RE
 *      because it is not a final method
 *      
 * Q13) If override start() method, do we have any other problem?     
 *      - yes, custom thread is not started
 *      - run() method is not executed
 *        
 * Q14) Then, What is the need of overriding start() method?
 * 		- for executing some logic compulsory before every thread start
 * 		  we must  place this logic in start() method by overriding it        
 * 	
 * Q15) What is the right design for overriding start() method?
 * 		1. first we must place our logic inside overriding start() method 
 * 		2. then at the end of overriding start() method body 
 *         we must place super.start()
 *            
 * as shown below
 */
class MyThread10 extends Thread {
	
	@Override
	public void start() {
		System.out.println("start() start");
		
		System.out.println("start() end");
		super.start();
	}
	
	
	@Override
	public void run() {
		String name = getName();
		System.out.println(name + " run start");
		System.out.println(name + " run end");
	}
}

public class Test18_overridingStart {
	public static void main(String[] args) {
		System.out.println("main start");
		
		MyThread10 mt1 = new MyThread10();
		mt1.start();
		
		MyThread10 mt2 = new MyThread10();
		mt2.start();
		
		System.out.println("main end");
	}
}

====================================================================================================================================================================================
/**
 * Q16) Can we create a custom thread from other custom thread?
 * 		- yes, it is possible
 * 
 * Q17) What is the procedure?
 *      - create one thread class object and call start() method 
 *        in another thread class run() method
 *        
 *      - create the first thread class object and call start() method
 *        in main method
 *        
 *      - main thread starts thread1
 *      - thread1 starts thread2
 *         
 */
public class Test19_createCT_from_CT {
	public static void main(String[] args) {
		System.out.println("main start");
			MyThread11 mt1 = new MyThread11();
			mt1.start();
		System.out.println("main end");
	}
}

class MyThread11 extends Thread {
	@Override
	public void run() {
		System.out.println("MyThread11.run() start");
		
		MyThread12 mt2 = new MyThread12();
		mt2.start();
		
		System.out.println("MyThread11.run() end");	
	}
}

class MyThread12 extends Thread {
	@Override
	public void run() {
		System.out.println("MyThread12.run() start");
		
		System.out.println("MyThread12.run() end");
	}
}
====================================================================================================================================================================================

/**
 * Q18) Can we start a custom thread from the same custom thread's run() method?
 * 		- yes, we can start
 * 
 * Q19) Then what is the execution flow, will it leads to recursion and will it leads to SOfError?
 * 		- It leads recursion, infinite number of custom threads are keep on created and destroyed
 * 		- The program execution is never terminated and we will not get StackOverflowError,
 *        because every time run() method is executed in new thread, not in the same thread
 *        
 * Q20) In place of start() method if we call run() method, what will happen?
 * 		- now we will StackOverflowError
 * 		- because new custom thread is not created
 * 		  every time for run() method call, run() method is loaded in the same current thread
 * 		- At some point of the time, thread memory is filled, no space for loading run() method logic
 * 		  JVM terminates this thread execution by throwing SOfError 
 *                   
 */
public class Test20_creatingCT_from_sameCT {
	
	public static void main(String[] args) {
		System.out.println("main start");
		
		MyThread13 mt1 = new MyThread13();
		mt1.start(); //Thread-0 is ready-to-run
		
		System.out.println("main run");
	}
}

class MyThread13 extends Thread {
	
	@Override
	public void run() {
		String name = Thread.currentThread().getName();
		System.out.println(name + " run start");
		
		MyThread13 mt2 = new MyThread13();
		mt2.start();
		//mt2.run();
		System.out.println(name + " run end"); 
	}	 
}
